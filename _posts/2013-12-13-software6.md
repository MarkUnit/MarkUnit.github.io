---
layout: post
title: 高级软件工程整理（六）
description: "理论整理"
category: 整理
tags: [software]
---
{% include JB/setup %}

名词解释

软件工程：简单的理解，软件工程就是生产软件的工程学。

1）应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。

2）对1各种方法的研究

从1950s~2000s之间的特点。。。。。。。。

如何管理团队？

1.建立团队章程

2.持续成功

3.和谐沟通

质量保障有哪些措施？。。。。。

配置管理有哪些活动？

1.标识配置项
2.版本控制
3.变更控制
4配置审计
5状态报告
6软件发布管理

解释需求：

1.用户为了解决问题或达到某些目标所需要的条件和能力；
2.系统或系统部件为了满足合同，标准，规范或其他正式文档所规定的要求而需要具备的条件或能力；
3. 对1、2中的一个条件或一种能力的一种文档化表述。


区分需求的三个层次

1.业务需求
2.用户需求
3系统级需求

掌握需求的类型

1.功能需求

2.性能需求 （速度，容量，吞吐量，负载，实时性）

3质量属性（可靠性、可用性、安全性、可维护、可一致性、易用性）

4对外接口（接口的用途。接口的输入、输出、数据格式、命令格式、异常处理要求）

5约束

6数据需求

为给定的描述
建立 用例图（基本元素有：用例，参与者，关系，系统边界）
建立 分析类图（基本元素有：对象、类、链接、关联、继承）
建立 系统顺序图
建立 状态图

为什么需要需求规格说明？

软件需求视项目中需要进行广泛交流的内容之一，所以需求开发阶段需要进行需求的文档化。

软件设计
软件设计是关于软件对象的设计，是一种设计活动，软件设计既是指软件对象
实现的规格说明，也是指产生这个规格说明的过程。


软件设计有哪两个方面？
分解，抽象

软件工程设计有哪三个层次？
高层，
基于反应软件高层抽象的构件层次，描述系统的高层结构，关注点，和设计决策。

中层，
更加关注组成构建的模块的划分，导入与导出，过程之间调用关系或者类之间的协作。

低层，
则深入模块和类的内部，关注具体的数据结构，算法，类型，语句，控制结构。

说明体系结构设计是如何进行的？

1.分析关键需求和项目的约束

2.选择体系结构风格

3进行软件体系结构逻辑设计

4依赖逻辑设计进行软件体系结构的物理设计

5完善软件体系结构设计

6定义构建接口

7迭代过程3~6

。。。。。。。。。
信息专家模式
控制模式
创建者模式


三种控制风格

1 主程序/子程序
2 面向对象式
3 分层
4 MVC

耦合与内聚（结构化设计中的）

耦合：

内容耦合

公共耦合

重复耦合

控制耦合

印记耦合

数据耦合

内聚：

偶然内聚

逻辑内聚

时间内聚

过程内聚

通信内聚

功能内聚

信息内聚

耦合与内聚（面向对象）

耦合：

1.方法调用耦合

2.访问耦合

3继承耦合

内聚（面向对象）
1 方法的内聚
2 类的内聚
3 子类与父类的继承内聚



信息隐藏
基本思想

两种常见的信息隐藏决策
1 职责的实现
2 实现的变更

九大原则：

接口分离原则ISP：

依赖倒置原则DIP：

抽象不应该依赖于细节，细节应该依赖于抽象，因为抽象是稳定的，细节是不稳定的

高级模块不应该依赖于低级模块，而是双方都依赖于抽象。因为抽象是稳定的，而高层模块和底层模块都可能是不稳定的。

可替代性LSP原则：

只要调用一个接口，不论是哪种子类或者父类自身，都可以完成相同语义的工作。(Liskov Substitution Principle)

Demeter法则:

1:每个单元对于其他的单元只能拥有有限的知识，只是与当前的单元紧密联系的单元；

2；每个单元只能和它的朋友交谈，不能和陌生单元交谈

3：只和自己的直接的朋友交谈。

开闭原则OCP：

1. 好的设计是应该是对“扩展”是开放的；

2 好的设计应该修改关闭；


单一职责SRP：

一个高内聚的类不仅要是信息内聚的，还应该是功能内聚的。信息与行为除了要集中之外，还要联合起来表达一个内聚的概念，而不是单纯的堆砌。这个就是单一职责原则。


对上述原则，说明其优点与机理

信息隐藏的法则


名词解释
设计模式
掌握各种模式
迭代器、策略、工厂、工厂方法、单件、命令
问题、结构、效果
给定场景，应用设计模式并写出代码
给出代码，要求用设计模式改写

算法的可修改性与多种算法并存
对象树的创建
REDO/UNDO

名词解释
可用性
能够列出至少5个界面设计的注意事项，并加以解释
违反了哪些条界面设计原则

名词解释：
软件构造
掌握TDD方法
TDD的步骤
对限定需求的方法，写驱动的测试用例

给定代码段示例，对其进行改进
或者 发现其中的问题
简洁性/可维护性
使用数据结构消减复杂判定
控制结构
变量使用
语句处理

How to write unmaintainable code
防御与错误处理

白盒测试和黑盒测试的常见方法，优缺点比较
白盒测试三种不同的方法：语句覆盖、分支覆盖和路径覆盖

如何理解软件维护的重要性

如何理解演化式开发？

Build-and-fix model
Waterfall model
Iterative Models
Incremental model
Incremental Delivery
Evolutionary
Evolutionary development
Prototyping
Spiral Model


